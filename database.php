<?php
/*
Holds functions pertaining to the database
*/
require_once "./config.php";
class Database
{
	/*
		Creates a connection to the database if it does not already exist
		If a connection exists then return that connection
	*/
	public static function connect()
	{
		//$conn holds the connection to the database if it has been opened already
		//otherwise, a connection is created and $conn points to that connection
		static $conn;

		//If there is already an existing connection, return that connection
		if ( $conn )
			return $conn;

		$dbName = Config::$DB_NAME;//"SENATE";
		$dbUser = Config::$DB_USER;//"root";
		$dbPass = Config::$DB_PASS;//"";
		$dbHost = Config::$DB_HOST;
		$dataSrc = "mysql:host={$dbHost};dbname={$dbName}";
		try 
		{
			//create the connection with the parameters given
			$conn = new PDO( $dataSrc, $dbUser , $dbPass );
			//make associative arrays the default so that $stmt->fetch() doesn't need PDO::FETCH_ASSOC every time
			$conn->setAttribute( PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC );
		} 
		catch ( PDOException $e ) 
		{
			echo "Error establishing Connection<br>";
			echo "{$e->getMessage()}<br>";
			exit();
		}

		return $conn;
	}

	/*
		Generates a random token for CSRF prevention.
		Length is the number of bytes that will be generated.
		Returns the hexadecimal representation of the generated bytes as a string.
	*/
	public static function randomToken( $length = 32 )
	{
		$strong = false;
		$bytes = openssl_random_pseudo_bytes( $length, $strong );
		//if strong is false, then the bytes were not generated with a cryptographically strong algorithm
		//	if that is the case, then error out
		if ( $strong !== true )
		{
			echo "Could not generate secure token<br>";
			exit();			
		}

		return bin2hex( $bytes );
	}

	/*
		Sanitizes the input given to prevent XSS.
	*/
	public static function sanitizeData( $str )
	{
		return htmlspecialchars( $str, ENT_QUOTES, 'UTF-8', false);		
	}

	/*
		Reverts the input given back to its original form, meaning any HTML tags will be there.
	*/
	public static function unsanitizeData( $str )
	{
		return ( htmlspecialchars_decode( $str, ENT_QUOTES ) );
	}

	/*
		Returns the hashed value of the token provided.
	*/
	public static function hashToken( $token )
	{
		return hash( "SHA-512" , $token, FALSE );
	}

	/*
		Returns true if the token matches the hashed provided or false otherwise.
	*/
	public static function hashVerify( $hashed, $token )
	{
		return ( self::hashToken( $token ) === $hashed );
	}

}

?>
